# 4. 认识所有权
所有权（系统）是Rust最为与众不同的特性，对语言的其他部分有着深刻含义。它让rust无需垃圾回收（ garbage collector）即可保障内存安全，因此理解rust中所有权如何工作是十分重要的。本章，我们将讲道所有权以及相关功能：借用（borrowing），slice以及rust如何在内存中布局数据。

## 4.1 什么是所有权
所有权（ownership）是rust用于如何管理内存的一组规则。所有程序都必须管理其运行使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时有规律地寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。rust选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序都运行。

因为所有权对很多程序员来说都是一个新概念，需要一些时间来适应。好消息是随着你对rust何所有权系统规则越来越有经验，你就越能自然地编写出安全和高效的代码。持之以恒！

**所有权规则**

首先，让我们看一下所有权的规则。当我们通过举例说明时，请谨记这些规则：
1. rust中的每一个值都有一个所有者。
2. 值在任一时刻有且只有一个所有者。
3. 当所有者离开作用域，这个值将被丢弃。

**变量作用域**

既然我们已经掌握了基本语法，将不会在之后的例子中包含fn main() {代码，所以如果你是一路跟过来的，必须手动将之后的例子代码放入一个main函数中。这样，例子将显得更加简明，使我们可以关注实际细节而不是样板代码。

在所有权的第一个例子中，我们看看一下变量的作用域（scope）。作用域是一个项（item）在程序中有效的范围。假设有这样一个变量：
```rust
let s = "hello";
```

变量s绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。这个变量从圣母的点开始直到当前作用域结束时都是有效的。示例4-1的注释标明了变量s在何处是有效的。

```rust
{ // s 在这里无效，它尚未声明
  let s = "hell";  //从此处起，s是有效的
  // 使用s 
}  //此作用域已结束， s不再有效
```
示例4-1：一个变量和其有效的作用域

换句话说，这里有两个重要的时间点：
+ 当s进入作用域时，它就是有效的。
+ 这一直持续到它离开作用域为止。

目前为止，变量是否有效与作用域的关系跟其他编程语言是类似的。现在我们在此基础上介绍String类型。

**String类型**

为了演示所有权的规则，我们需要一个比第三章“数据类型”中讲到的都要复杂的数据类型。前面介绍的类型都是已知大小的，可以存储在栈中，并且当离开作用域时被移出栈，如果代码的另一部分需要在不同的作用域中使用相同的值，可以快速简单的复制它们来创建一个新的独立实例。不过我们需要寻找一个存储在堆上的数据来探索rust是如何知道该在何时清理数据的，而String类型就是一个很好的例子。

我们会专注于String与所有权相关的部分。这些方面也同样适用于标准库提供的或你自己创建的其他复杂数据类型。在第八章会更深入地讲解String.

我们已经见过字符串字母值，即被硬编码进程序里的字符串值。字符串值是很方便的，不过它们并不适合使用文本的每一种场景。原因之一就是它们是不可变的。另一个原因是并非所有字符串的值都能在编写代码时就知道。例如，要是想获取用户输入并存储该怎么办呢？为此，rust有另一种字符串类型，String。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用from函数基于字符串字面值来创建String，如下：
这两个冒号：：是运算符，允许将特定的from函数置于String类型的命名空间（namespace）下，而不需要使用类似string_from这样的名字。在第五章的方法语法（Method Syntax）部分会着重讲解这个语法，而且在第七章的路径用于引用模块树中的项中会讲到模块的命名空间。。
```rust
  let mut s = String::from("hello");
  s.push_string(", world!"); // push_str() 在字符串后追加字面值
  println!("{s}"); //将打印 hello, world
```

那么这里有什么区别呢？为什么String可变而字面值却不行呢？区别在于两个类型对内存的处理上。

**内存与分配**

在字符串字面值来说，我们在编译时就知道其内容，所以文本被之间硬编码进最终的可执行文件中。这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。

对于String类型，为了支持异构可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：
+ 必须在运行时向内存分配器(memory allocator)请求内存。
+ 需要一个当我们处理完String时将内存返回给分配器的方法。

第一部分由我们完成：当调用String::from时，它的实现(implementation)请求其所需的内存。这在编程中是非常通用的。

然而，第二部分实现起来就各有区别了。在有垃圾回收（garbage collector， GC）的语言中，GC记录并清除不再使用的内存，而我们并不需要关心它。在大部分没有GC的语言中，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是一个bug。我们需要精确的为一个allocate配对一个free。

rust采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。下面是示例4-1中作用域例子的一个使用String而不是字符串字面值的版本：

```rust
{
  let s = String::from("hello");// 从此处起，s是有效的
  // 使用s   
}  //此作用域已结束，
//s 不再有效
```
这是一个将String需要的内存返回给分配器的很自然的位置：当s离开作用域的时候，当变量离开作用域，rust为我们调用一个特殊的函数。这个函数叫做drop，在这里String的作者可以放置释放内存的代码。rust在结尾的}处自动调用drop。

这个模式对编写rust代码的方式有着深远的影响。现在它看起来很简单，不过在更复杂的场景下代码的行为可能是不可预测的，比如当有多个变量使用在堆上分配的内存时。现在让我们探索一些这样的场景。

### 使用移动的变量与数据交互
